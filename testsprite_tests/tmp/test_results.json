[
  {
    "projectId": "4f416926-6cec-4356-9210-3b048f2cd3ee",
    "testId": "e8389816-16c5-41be-adb7-4561019ea211",
    "userId": "34386428-f0e1-707a-bcac-6510fa484466",
    "title": "TC001-register a new user with valid data",
    "description": "Test the /auth/register endpoint to ensure a new user can be registered successfully with valid email, password, fullName, tenantId, and roleId. Verify that the response status is 201 and the user is created.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nREGISTER_ENDPOINT = f\"{BASE_URL}/auth/register\"\nDELETE_USER_ENDPOINT_TEMPLATE = f\"{BASE_URL}/users/{{user_id}}\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\n# Use provided existing tenant and a sample valid roleId for testing\nEXISTING_TENANT_ID = \"11111111-1111-1111-1111-111111111111\"\n# For roleId, since no explicit existing roleId provided, we create a dummy guid here\n# Usually, roleId should be valid, but in absence of provided data, we'll generate a uuid for demonstration\n# Note: If this causes 400 errors, an actual existing roleId must be provided.\nEXISTING_ROLE_ID = \"22222222-2222-2222-2222-222222222222\"\n\n\ndef test_register_new_user_with_valid_data():\n    # Unique email to avoid conflict\n    unique_email = f\"testsprite+{uuid.uuid4()}@qflow.com\"\n    payload = {\n        \"email\": unique_email,\n        \"password\": \"TestSprite123!\",\n        \"fullName\": \"Test Sprite\",\n        \"tenantId\": EXISTING_TENANT_ID,\n        \"roleId\": EXISTING_ROLE_ID,\n    }\n\n    user_id = None\n    try:\n        response = requests.post(REGISTER_ENDPOINT, json=payload, headers=HEADERS, timeout=TIMEOUT)\n        # Assert status code is 201 Created\n        assert response.status_code == 201, f\"Expected status 201, got {response.status_code}\"\n\n        # The response may or may not include user info. We try to extract user ID if present\n        # Assuming response JSON contains user info with 'id' or 'userId'\n        try:\n            data = response.json()\n            # Try to find user id from response keys\n            user_id = data.get(\"id\") or data.get(\"userId\")\n        except Exception:\n            user_id = None\n\n        # Additional assertion: user_id should be present ideally, but if not, test still passes by API spec\n        # If user_id is None, we cannot delete the user in cleanup\n\n    finally:\n        if user_id:\n            # Attempt to delete user to clean up test data, ignoring failure\n            try:\n                del_resp = requests.delete(\n                    DELETE_USER_ENDPOINT_TEMPLATE.format(user_id=user_id),\n                    headers=HEADERS,\n                    timeout=TIMEOUT,\n                )\n                # No assert here; just try best effort cleanup\n            except Exception:\n                pass\n\n\ntest_register_new_user_with_valid_data()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-15T04:36:18.912Z",
    "modified": "2026-01-15T04:36:35.578Z"
  },
  {
    "projectId": "4f416926-6cec-4356-9210-3b048f2cd3ee",
    "testId": "54703974-f4fb-4c56-8546-823fe4d23185",
    "userId": "34386428-f0e1-707a-bcac-6510fa484466",
    "title": "TC002-handle duplicate user registration",
    "description": "Test the /auth/register endpoint with an email that already exists in the system to verify that the API returns a 409 conflict response indicating the user already exists.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nREGISTER_ENDPOINT = f\"{BASE_URL}/auth/register\"\nTIMEOUT = 30\n\n# Use an existing email to test duplicate registration\nEXISTING_EMAIL = \"testsprite@qflow.com\"\nPASSWORD = \"TestSprite123!\"\nFULL_NAME = \"Test Sprite\"\nTENANT_ID = \"11111111-1111-1111-1111-111111111111\"\nROLE_ID = \"00000000-0000-0000-0000-000000000000\"  # Assuming a placeholder roleId for the test\n\n\ndef test_handle_duplicate_user_registration():\n    # Payload with an existing email that is already registered\n    payload = {\n        \"email\": EXISTING_EMAIL,\n        \"password\": PASSWORD,\n        \"fullName\": FULL_NAME,\n        \"tenantId\": TENANT_ID,\n        \"roleId\": ROLE_ID,\n    }\n    headers = {\"Content-Type\": \"application/json\"}\n\n    try:\n        response = requests.post(\n            REGISTER_ENDPOINT, json=payload, headers=headers, timeout=TIMEOUT\n        )\n    except requests.RequestException as e:\n        assert False, f\"Request to register endpoint failed: {e}\"\n\n    # Validate the response status code is 409 Conflict indicating user already exists\n    assert response.status_code == 409, (\n        f\"Expected status code 409 for duplicate registration, \"\n        f\"got {response.status_code} with response: {response.text}\"\n    )\n\n\ntest_handle_duplicate_user_registration()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-15T04:36:18.920Z",
    "modified": "2026-01-15T04:36:38.440Z"
  },
  {
    "projectId": "4f416926-6cec-4356-9210-3b048f2cd3ee",
    "testId": "b7e7127d-49e6-44e4-a05b-c7d84c738cde",
    "userId": "34386428-f0e1-707a-bcac-6510fa484466",
    "title": "TC003-login user with correct credentials",
    "description": "Test the /auth/login endpoint by providing valid email and password to verify that the user is authenticated successfully and a JWT accessToken is returned with a 200 status.",
    "code": "import requests\n\ndef test_login_user_with_correct_credentials():\n    base_url = \"http://localhost:3000\"\n    endpoint = \"/auth/login\"\n    url = base_url + endpoint\n    payload = {\n        \"email\": \"testsprite@qflow.com\",\n        \"password\": \"TestSprite123!\"\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=30)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    assert \"accessToken\" in data, \"Response JSON does not contain 'accessToken'\"\n    assert isinstance(data[\"accessToken\"], str) and data[\"accessToken\"], \"'accessToken' should be a non-empty string\"\n\ntest_login_user_with_correct_credentials()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-15T04:36:18.926Z",
    "modified": "2026-01-15T04:36:36.400Z"
  },
  {
    "projectId": "4f416926-6cec-4356-9210-3b048f2cd3ee",
    "testId": "f00f9a8a-a272-434b-bd51-51e2e63af227",
    "userId": "34386428-f0e1-707a-bcac-6510fa484466",
    "title": "TC004-reject login with invalid credentials",
    "description": "Test the /auth/login endpoint with incorrect email or password to ensure the API returns a 401 unauthorized response.",
    "code": "import requests\n\ndef test_reject_login_with_invalid_credentials():\n    base_url = \"http://localhost:3000\"\n    endpoint = \"/auth/login\"\n    url = base_url + endpoint\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Test with incorrect email\n    invalid_email_payload = {\n        \"email\": \"wrongemail@qflow.com\",\n        \"password\": \"TestSprite123!\"\n    }\n\n    try:\n        response = requests.post(url, json=invalid_email_payload, headers=headers, timeout=30)\n        assert response.status_code == 401, f\"Expected 401 but got {response.status_code} for invalid email\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    # Test with incorrect password\n    invalid_password_payload = {\n        \"email\": \"testsprite@qflow.com\",\n        \"password\": \"WrongPassword!\"\n    }\n\n    try:\n        response = requests.post(url, json=invalid_password_payload, headers=headers, timeout=30)\n        assert response.status_code == 401, f\"Expected 401 but got {response.status_code} for invalid password\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_reject_login_with_invalid_credentials()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-15T04:36:18.932Z",
    "modified": "2026-01-15T04:36:39.725Z"
  },
  {
    "projectId": "4f416926-6cec-4356-9210-3b048f2cd3ee",
    "testId": "4d2b5ba0-e066-496c-b1e8-d007c8143238",
    "userId": "34386428-f0e1-707a-bcac-6510fa484466",
    "title": "TC005-logout authenticated user successfully",
    "description": "Test the /auth/logout endpoint with a valid bearer token to verify that the user session is invalidated and a 200 status is returned confirming successful logout.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nLOGIN_EMAIL = \"testsprite@qflow.com\"\nLOGIN_PASSWORD = \"TestSprite123!\"\nTIMEOUT = 30\n\ndef test_logout_authenticated_user_successfully():\n    # Step 1: Login to get valid bearer token\n    login_url = f\"{BASE_URL}/auth/login\"\n    login_payload = {\n        \"email\": LOGIN_EMAIL,\n        \"password\": LOGIN_PASSWORD\n    }\n    try:\n        login_response = requests.post(login_url, json=login_payload, timeout=TIMEOUT)\n        assert login_response.status_code == 200, f\"Login failed with status {login_response.status_code}\"\n        login_data = login_response.json()\n        access_token = login_data.get(\"accessToken\")\n        assert access_token is not None, \"No accessToken in login response\"\n    except Exception as e:\n        raise Exception(f\"Login request failed: {e}\")\n\n    # Step 2: Logout with bearer token\n    logout_url = f\"{BASE_URL}/auth/logout\"\n    headers = {\n        \"Authorization\": f\"Bearer {access_token}\"\n    }\n    try:\n        logout_response = requests.post(logout_url, headers=headers, timeout=TIMEOUT)\n        assert logout_response.status_code == 200, f\"Logout failed with status {logout_response.status_code}\"\n    except Exception as e:\n        raise Exception(f\"Logout request failed: {e}\")\n\n\ntest_logout_authenticated_user_successfully()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-15T04:36:18.938Z",
    "modified": "2026-01-15T04:36:37.917Z"
  },
  {
    "projectId": "4f416926-6cec-4356-9210-3b048f2cd3ee",
    "testId": "ca6b9f7a-a4ff-4aa3-873a-f6d12f4a2d0d",
    "userId": "34386428-f0e1-707a-bcac-6510fa484466",
    "title": "TC006-reject logout without authentication",
    "description": "Test the /auth/logout endpoint without providing a valid bearer token to ensure the API returns a 401 unauthorized response.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\n\n\ndef test_reject_logout_without_authentication():\n    url = f\"{BASE_URL}/auth/logout\"\n    headers = {\n        # Intentionally no Authorization header to test unauthorized access\n    }\n    try:\n        response = requests.post(url, headers=headers, timeout=30)\n        assert response.status_code == 401, f\"Expected 401 Unauthorized, got {response.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed with exception: {e}\"\n\n\ntest_reject_logout_without_authentication()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-15T04:36:18.943Z",
    "modified": "2026-01-15T04:36:40.141Z"
  },
  {
    "projectId": "4f416926-6cec-4356-9210-3b048f2cd3ee",
    "testId": "b03c1174-d655-454a-9882-17fba897a863",
    "userId": "34386428-f0e1-707a-bcac-6510fa484466",
    "title": "TC007-setup mfa for authenticated user",
    "description": "Test the /auth/mfa/setup endpoint with a valid bearer token to verify that the API returns a QR code URL and secret for two-factor authentication setup with a 200 status.",
    "code": "import requests\n\ndef test_setup_mfa_for_authenticated_user():\n    base_url = \"http://localhost:3000\"\n    url = f\"{base_url}/auth/mfa/setup\"\n    token = (\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\"\n             \"eyJzdWIiOiJhODE2ZTI1Yy1lODljLTRmY2EtOGQ2MS1mODk5Y2UxNDEwYmIiLCJ0ZW5hbnRJZCI6IjExMTExMTExLTExMTEtMTExMS0xMTExLTExMTExMTExMTExMSIsImlhdCI6MTc2ODQ0Njg3OCwiZXhwIjoxNzY5MDUxNjc4fQ.\"\n             \"ipi_MNMLeB6iJbCBGX-UsztZKEi-GkIbONLYyKBKosI\")\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n    try:\n        response = requests.post(url, headers=headers, timeout=30)\n        assert response.status_code == 200, f\"Expected 200 OK but got {response.status_code}\"\n        json_data = response.json()\n        assert \"qrCodeUrl\" in json_data, \"Response JSON missing 'qrCodeUrl'\"\n        assert isinstance(json_data[\"qrCodeUrl\"], str) and json_data[\"qrCodeUrl\"], \"'qrCodeUrl' should be a non-empty string\"\n        assert \"secret\" in json_data, \"Response JSON missing 'secret'\"\n        assert isinstance(json_data[\"secret\"], str) and json_data[\"secret\"], \"'secret' should be a non-empty string\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_setup_mfa_for_authenticated_user()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-15T04:36:18.949Z",
    "modified": "2026-01-15T04:36:40.975Z"
  },
  {
    "projectId": "4f416926-6cec-4356-9210-3b048f2cd3ee",
    "testId": "2e663923-4b7c-406b-8304-e13015d8c47a",
    "userId": "34386428-f0e1-707a-bcac-6510fa484466",
    "title": "TC008-reject mfa setup without authentication",
    "description": "Test the /auth/mfa/setup endpoint without a valid bearer token to ensure the API returns a 401 unauthorized response.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_reject_mfa_setup_without_authentication():\n    url = f\"{BASE_URL}/auth/mfa/setup\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    try:\n        response = requests.post(url, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 401, f\"Expected status code 401, got {response.status_code}\"\n\ntest_reject_mfa_setup_without_authentication()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-15T04:36:18.955Z",
    "modified": "2026-01-15T04:36:41.456Z"
  },
  {
    "projectId": "4f416926-6cec-4356-9210-3b048f2cd3ee",
    "testId": "03411813-2285-4d4c-aef3-54a63cf2d568",
    "userId": "34386428-f0e1-707a-bcac-6510fa484466",
    "title": "TC009-check stock availability with sufficient stock",
    "description": "Test the /inventory/check-availability endpoint by providing a valid variantId, branchId, and quantity that is available in stock. Verify the API returns a 200 status with availability confirmed.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTOKEN = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhODE2ZTI1Yy1lODljLTRmY2EtOGQ2MS1mODk5Y2UxNDEwYmIiLCJ0ZW5hbnRJZCI6IjExMTExMTExLTExMTEtMTExMS0xMTExLTExMTExMTExMTExMSIsImlhdCI6MTc2ODQ0Njg3OCwiZXhwIjoxNzY5MDUxNjc4fQ.ipi_MNMLeB6iJbCBGX-UsztZKEi-GkIbONLYyKBKosI\"\nVARIANT_ID = \"66666666-6666-6666-6666-666666666666\"\nBRANCH_ID = \"33333333-3333-3333-3333-333333333333\"\nTIMEOUT = 30\n\n\ndef test_check_stock_availability_with_sufficient_stock():\n    url = f\"{BASE_URL}/inventory/check-availability\"\n    headers = {\n        \"Authorization\": f\"Bearer {TOKEN}\",\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n    payload = {\n        \"variantId\": VARIANT_ID,\n        \"branchId\": BRANCH_ID,\n        \"quantity\": 50  # less than available stock 100\n    }\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not a valid JSON\"\n\n    # We expect a key or property indicating stock availability status\n    # Since PRD doesn't specify exact response schema, check for a plausible confirmation\n    # For example, response might have {\"available\": true} or similar\n    assert (\"available\" in data and data[\"available\"] is True) or \\\n           (\"isAvailable\" in data and data[\"isAvailable\"] is True), \\\n           f\"Expected availability confirmed in response but got {data}\"\n\ntest_check_stock_availability_with_sufficient_stock()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-15T04:36:18.961Z",
    "modified": "2026-01-15T04:36:44.618Z"
  },
  {
    "projectId": "4f416926-6cec-4356-9210-3b048f2cd3ee",
    "testId": "cf5df2cb-129d-4db5-a5c0-5f1db1040a85",
    "userId": "34386428-f0e1-707a-bcac-6510fa484466",
    "title": "TC010-create sale with valid data and sufficient stock",
    "description": "Test the /sales POST endpoint by submitting a valid sale request including branchId, cashierId, paymentMethod, and items with sufficient stock. Verify the sale is created successfully with a 201 response.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nEMAIL = \"testsprite@qflow.com\"\nPASSWORD = \"TestSprite123!\"\nTENANT_ID = \"11111111-1111-1111-1111-111111111111\"\nBRANCH_ID = \"33333333-3333-3333-3333-333333333333\"\nVARIANT_ID = \"66666666-6666-6666-6666-666666666666\"\nCASHIER_ID = \"ecdbde1b-223a-406f-89af-54b6799517bc\"\nPAYMENT_METHOD = \"cash\"\nTIMEOUT = 30\n\n\ndef test_create_sale_with_valid_data_and_sufficient_stock():\n    session = requests.Session()\n    try:\n        # Login to get JWT token\n        login_payload = {\"email\": EMAIL, \"password\": PASSWORD}\n        login_resp = session.post(f\"{BASE_URL}/auth/login\", json=login_payload, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        token = login_resp.json().get(\"accessToken\")\n        assert token, \"No accessToken in login response\"\n\n        headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        # Check stock availability (quantity=1 for test)\n        check_stock_payload = {\n            \"variantId\": VARIANT_ID,\n            \"branchId\": BRANCH_ID,\n            \"quantity\": 1\n        }\n        stock_resp = session.post(f\"{BASE_URL}/inventory/check-availability\", json=check_stock_payload, headers=headers, timeout=TIMEOUT)\n        assert stock_resp.status_code == 200, f\"Stock availability check failed with status {stock_resp.status_code}\"\n        availability_data = stock_resp.json()\n        # We expect availability confirmation (depending on actual API response shape)\n        # Typical success response could have e.g. {\"available\": true}\n        available = availability_data.get(\"available\")  # Could be named differently\n        assert available is True, f\"Stock not available for variantId {VARIANT_ID} at branchId {BRANCH_ID}\"\n\n        # Create sale with valid data and sufficient stock\n        sale_payload = {\n            \"branchId\": BRANCH_ID,\n            \"cashierId\": CASHIER_ID,\n            \"paymentMethod\": PAYMENT_METHOD,\n            \"items\": [\n                {\n                    \"variantId\": VARIANT_ID,\n                    \"quantity\": 1,\n                    \"unitPrice\": 10.0\n                }\n            ]\n        }\n        sale_resp = session.post(f\"{BASE_URL}/sales\", json=sale_payload, headers=headers, timeout=TIMEOUT)\n        assert sale_resp.status_code == 201, f\"Sale creation failed with status {sale_resp.status_code}\"\n\n    finally:\n        session.close()\n\n\ntest_create_sale_with_valid_data_and_sufficient_stock()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-15T04:36:18.966Z",
    "modified": "2026-01-15T04:36:43.969Z"
  }
]
